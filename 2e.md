You're correct! The `UPLOAD_FOLDER` should match the **Persistent Volume (PV) path** since Kubernetes mounts this storage into the API container.

Let's clarify how the **`UPLOAD_FOLDER`** and **PV storage** work together.

---

## 🎯 **Understanding the Upload Folder and Kubernetes PV**

1. **In the API Code**  
   The Flask API uses this configuration for the upload folder:

```python
UPLOAD_FOLDER = os.getenv("UPLOAD_FOLDER", "/data/videos")
```

- This means the API will save videos to `/data/videos` inside the **container**.

---

2. **In Kubernetes (PV & PVC Setup)**  
   The **Persistent Volume (PV)** is mapped to a **host path** like `/data/k8s/videos` and mounted into the API container at `/data/videos`.

**Example Kubernetes Volume Mount** (in `deployment.yaml`):

```yaml
volumeMounts:
  - name: video-storage
    mountPath: /data/videos
```

And the PV is defined as:

```yaml
hostPath:
  path: /data/k8s/videos
  type: DirectoryOrCreate
```

- This means that **inside the container**, the path `/data/videos` is actually mapped to `/data/k8s/videos` on the **host** machine.

---

### ✅ **Why Use `/data/videos` in the Code?**

- The API code is **container-agnostic**, so it works in any environment.  
- Kubernetes handles the mount, ensuring that `/data/videos` inside the container maps to the correct persistent storage on the host.  
- This approach makes the API code **clean and portable**, without hardcoding host-specific paths.

---

## ✅ **Updated `.env` Usage**

In development (without Kubernetes), you might manually set an environment variable:

```bash
export UPLOAD_FOLDER="/absolute/path/to/local/storage"
```

But in Kubernetes, the **`UPLOAD_FOLDER` is automatically mapped** via the volume mount to `/data/videos`, so **no manual export is required**.

---

## 🚀 **Updated README.md**

Here's the **full, clarified README** with explanations for `.env` and Kubernetes PV:

---

# 🎬 Orsi Video Platform

A minimal video platform using **React, Flask API, AI job processing**, and a **Kubernetes backend (k3s)**.

---

## 🚀 Quick Start Instructions

### 1. **Clone the Repository**

```bash
git clone https://github.com/your-repo/orsi-video-platform.git
cd orsi-video-platform
```

---

## ⚙️ Development Setup

### 🖥️ Frontend (React + TypeScript)

```bash
cd frontend/frontend-app
npm install
npm start
```

- Runs the frontend on [http://localhost:3000](http://localhost:3000).

---

### 🖥️ Backend (Flask API)

```bash
cd api
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python app.py
```

- Runs the API in development mode on [http://localhost:5000](http://localhost:5000).

---

### ✅ Environment Variables (Optional)

In development mode, you can create a `.env` file in the `api` directory to specify custom configurations.

**Example `.env` file:**

```env
UPLOAD_FOLDER=/absolute/path/to/local/videos
CORS_ORIGINS=http://localhost:3000
```

> **Note**: In Kubernetes, the `UPLOAD_FOLDER` is automatically set via volume mounts, so you don't need to set it manually.

---

## 🐳 Docker and Kubernetes Setup

### ✅ Build and Start with Kubernetes (k3s)

```bash
chmod +x start.sh
./start.sh
```

- This will:
  - Start Docker and k3s.
  - Build Docker images for the frontend and API.
  - Import Docker images into k3s.
  - Apply Kubernetes manifests for PV, PVC, Deployments, and Services.
  
> Access the services via:
- **Frontend**: `http://<wsl2-ip>:30001`  
- **API**: `http://<wsl2-ip>:30002`

---

### ⏹️ Stop and Cleanup

```bash
chmod +x stop.sh
./stop.sh
```

- This will:
  - Remove all Kubernetes resources.
  - Clean up Docker images and volumes.
  - Stop Docker and k3s.

---

## 📦 Kubernetes Details

### Persistent Volume (PV) and Persistent Volume Claim (PVC)

- **Host Path**: Video data is persisted at `/data/k8s/videos` on the host system.  
- **Container Path**: Inside the API container, it's accessible as `/data/videos`.
  
- **Why `/data/videos`?**  
  - Kubernetes automatically mounts the host directory into the container, ensuring persistence.  
  - The API only needs to save files to `/data/videos` (which maps to the persistent storage).

### Volume Example

- **Host Path**: `/data/k8s/videos`  
- **Container Path**: `/data/videos`

---

### Accessing Uploaded Videos (In Kubernetes)

- Videos uploaded through the API are stored in `/data/k8s/videos` on the host.  
- Kubernetes mounts this path automatically, ensuring persistence even if the container restarts.

---

### 🛠️ Check Kubernetes Resources

```bash
kubectl get pv
kubectl get pvc
kubectl get pods
kubectl get services
```

---

## 🧪 Testing Uploads

- Upload a video via the frontend.  
- Confirm it's saved in the host directory:

```bash
ls /data/k8s/videos
```

- Or check via API:

```bash
curl http://localhost:30002/videos
```

---

## 🚀 Debugging Tips

- Check Pod Logs:

```bash
kubectl logs <api-pod-name>
```

- Describe PVC if pending:

```bash
kubectl describe pvc video-pvc
```

- Rebuild and Restart Services:

```bash
./stop.sh && ./start.sh
```

---

## 🔥 Important Notes

- **Development**: Set the `UPLOAD_FOLDER` manually if running outside Kubernetes.  
- **Production (Kubernetes)**: No manual export needed, as Kubernetes manages volume mounts.

---

This README now gives **clear and detailed instructions** for both local development and Kubernetes deployments, ensuring clarity about the `UPLOAD_FOLDER` and persistent storage. 🚀